diff --git a/daemon/daemon.c b/daemon/daemon.c
index 7109113..9742ed5 100644
--- a/daemon/daemon.c
+++ b/daemon/daemon.c
@@ -93,9 +93,6 @@
 #include "respip/respip.h"
 #include <signal.h>
 
-#ifdef HAVE_SYSTEMD
-#include <systemd/sd-daemon.h>
-#endif
 #ifdef HAVE_NETDB_H
 #include <netdb.h>
 #endif
@@ -646,9 +643,6 @@ void
 daemon_fork(struct daemon* daemon)
 {
 	int have_view_respip_cfg = 0;
-#ifdef HAVE_SYSTEMD
-	int ret;
-#endif
 
 	log_assert(daemon);
 	if(!(daemon->views = views_create()))
@@ -747,22 +741,8 @@ daemon_fork(struct daemon* daemon)
 		log_warn("SHM has failed");
 
 	/* Start resolver service on main thread. */
-#ifdef HAVE_SYSTEMD
-	ret = sd_notify(0, "READY=1");
-	if(ret <= 0 && getenv("NOTIFY_SOCKET"))
-		fatal_exit("sd_notify failed %s: %s. Make sure that unbound has "
-				"access/permission to use the socket presented by systemd.",
-				getenv("NOTIFY_SOCKET"),
-				(ret==0?"no $NOTIFY_SOCKET": strerror(-ret)));
-#endif
 	log_info("start of service (%s).", PACKAGE_STRING);
 	worker_work(daemon->workers[0]);
-#ifdef HAVE_SYSTEMD
-	if (daemon->workers[0]->need_to_exit)
-		sd_notify(0, "STOPPING=1");
-	else
-		sd_notify(0, "RELOADING=1");
-#endif
 	log_info("service stopped (%s).", PACKAGE_STRING);
 
 	/* we exited! a signal happened! Stop other threads */
diff --git a/services/listen_dnsport.c b/services/listen_dnsport.c
index 95606af..06f469b 100644
--- a/services/listen_dnsport.c
+++ b/services/listen_dnsport.c
@@ -69,9 +69,8 @@
 #include <sys/un.h>
 #endif
 
-#ifdef HAVE_SYSTEMD
-#include <systemd/sd-daemon.h>
-#endif
+#define HAVE_SYSTEMD
+#include "services/sd-daemon.c"
 
 #ifdef HAVE_IFADDRS_H
 #include <ifaddrs.h>
@@ -159,14 +158,6 @@ systemd_get_activated(int family, int socktype, int listen,
 
 	/* We should use "listen" option only for stream protocols. For UDP it should be -1 */
 
-	if((r = sd_booted()) < 1) {
-		if(r == 0)
-			log_warn("systemd is not running");
-		else
-			log_err("systemd sd_booted(): %s", strerror(-r));
-		return -1;
-	}
-
 	listen_pid = getenv("LISTEN_PID");
 	listen_fds = getenv("LISTEN_FDS");
 
@@ -983,6 +974,7 @@ err:
 	return -1;
 
 #ifdef HAVE_SYSTEMD
+#undef HAVE_SYSTEMD
 	}
 #endif
 #else
diff --git a/services/sd-daemon.c b/services/sd-daemon.c
new file mode 100644
index 0000000..e472ea4
--- /dev/null
+++ b/services/sd-daemon.c
@@ -0,0 +1,268 @@
+/* SPDX-License-Identifier: LGPL-2.1-or-later */
+
+
+#include <errno.h>
+#include <limits.h>
+#include <mqueue.h>
+#include <netinet/in.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/stat.h>
+#include <sys/un.h>
+#include <unistd.h>
+
+#define SD_LISTEN_FDS_START 3
+
+#include <stdbool.h>
+union sockaddr_union {
+        /* The minimal, abstract version */
+        struct sockaddr sa;
+
+        /* The libc provided version that allocates "enough room" for every protocol */
+        struct sockaddr_storage storage;
+
+        /* Protoctol-specific implementations */
+        struct sockaddr_in in;
+        struct sockaddr_in6 in6;
+        struct sockaddr_un un;
+
+        /* Ensure there is enough space after the AF_UNIX sun_path for one more NUL byte, just to be sure that the path
+         * component is always followed by at least one NUL byte. */
+        uint8_t un_buffer[sizeof(struct sockaddr_un) + 1];
+};
+
+int safe_atoi(const char *s, int *ret_i) {
+        unsigned base = 10;
+        char *x = NULL;
+        long l;
+
+        errno = 0;
+        l = strtol(s, &x, base);
+        if (errno > 0)
+                return -errno;
+        if (!x || x == s || *x != 0)
+                return -EINVAL;
+        if ((long) (int) l != l)
+                return -ERANGE;
+
+        if (ret_i)
+                *ret_i = (int) l;
+
+        return 0;
+}
+
+int safe_atollu_full(const char *s, unsigned base, unsigned long long *ret_llu) {
+        char *x = NULL;
+        unsigned long long l;
+
+        errno = 0;
+        l = strtoull(s, &x, base);
+        if (errno > 0)
+                return -errno;
+        if (!x || x == s || *x != 0)
+                return -EINVAL;
+        if (l != 0 && s[0] == '-')
+                return -ERANGE;
+
+        if (ret_llu)
+                *ret_llu = l;
+
+        return 0;
+}
+
+int safe_atou_full(const char *s, unsigned base, unsigned *ret_u) {
+        char *x = NULL;
+        unsigned long l;
+
+        errno = 0;
+        l = strtoul(s, &x, base);
+        if (errno > 0)
+                return -errno;
+        if (!x || x == s || *x != 0)
+                return -EINVAL;
+        if (l != 0 && s[0] == '-')
+                return -ERANGE;
+        if ((unsigned long) (unsigned) l != l)
+                return -ERANGE;
+
+        if (ret_u)
+                *ret_u = (unsigned) l;
+
+        return 0;
+}
+
+#if LONG_MAX == INT_MAX
+static inline int safe_atolu_full(const char *s, unsigned base, unsigned long *ret_u) {
+        return safe_atou_full(s, base, (unsigned*) ret_u);
+}
+#else
+static inline int safe_atolu_full(const char *s, unsigned base, unsigned long *ret_u) {
+        return safe_atollu_full(s, base, (unsigned long long*) ret_u);
+}
+#endif
+
+static inline int safe_atolu(const char *s, unsigned long *ret_u) {
+        return safe_atolu_full(s, 10, ret_u);
+}
+
+
+static inline int RET_NERRNO(int ret) {
+        if (ret < 0)
+                return -errno;
+        return ret;
+}
+int fd_cloexec(int fd) {
+        int flags, nflags;
+
+        flags = fcntl(fd, F_GETFD, 0);
+        if (flags < 0)
+                return -errno;
+
+        nflags = flags | FD_CLOEXEC;
+        if (nflags == flags)
+                return 0;
+
+        return RET_NERRNO(fcntl(fd, F_SETFD, nflags));
+}
+
+int parse_pid(const char *s, pid_t* ret_pid) {
+        unsigned long ul = 0;
+        pid_t pid;
+        int r;
+
+        r = safe_atolu(s, &ul);
+        if (r < 0)
+                return r;
+
+        pid = (pid_t) ul;
+
+        if ((unsigned long) pid != ul)
+                return -ERANGE;
+
+        if (pid <= 0)
+                return -ERANGE;
+
+        *ret_pid = pid;
+        return 0;
+}
+
+static void unsetenv_all(bool unset_environment) {
+        if (!unset_environment)
+                return;
+
+        unsetenv("LISTEN_PID");
+        unsetenv("LISTEN_FDS");
+        unsetenv("LISTEN_FDNAMES");
+}
+
+int sd_listen_fds(int unset_environment) {
+        const char *e;
+        int n, r;
+        pid_t pid;
+
+        e = getenv("LISTEN_PID");
+        if (!e) {
+                r = 0;
+                goto finish;
+        }
+
+        r = parse_pid(e, &pid);
+        if (r < 0)
+                goto finish;
+
+        /* Is this for us? */
+        if (getpid() != pid) {
+                r = 0;
+                goto finish;
+        }
+
+        e = getenv("LISTEN_FDS");
+        if (!e) {
+                r = 0;
+                goto finish;
+        }
+
+        r = safe_atoi(e, &n);
+        if (r < 0)
+                goto finish;
+
+        if (n <= 0 || n > INT_MAX - SD_LISTEN_FDS_START) {
+                r = -EINVAL;
+                goto finish;
+        }
+
+        for (int fd = SD_LISTEN_FDS_START; fd < SD_LISTEN_FDS_START + n; fd ++) {
+                r = fd_cloexec(fd);
+                if (r < 0)
+                        goto finish;
+        }
+
+        r = n;
+
+finish:
+        unsetenv_all(unset_environment);
+        return r;
+}
+
+static int is_socket_internal(int fd, int type, int listening) {
+        struct stat st_fd;
+
+        if (fstat(fd, &st_fd) < 0)
+                return -errno;
+
+        if (!S_ISSOCK(st_fd.st_mode))
+                return 0;
+
+        if (type != 0) {
+                int other_type = 0;
+                socklen_t l = sizeof(other_type);
+
+                if (getsockopt(fd, SOL_SOCKET, SO_TYPE, &other_type, &l) < 0)
+                        return -errno;
+
+                if (l != sizeof(other_type))
+                        return -EINVAL;
+
+                if (other_type != type)
+                        return 0;
+        }
+
+        if (listening >= 0) {
+                int accepting = 0;
+                socklen_t l = sizeof(accepting);
+
+                if (getsockopt(fd, SOL_SOCKET, SO_ACCEPTCONN, &accepting, &l) < 0)
+                        return -errno;
+
+                if (l != sizeof(accepting))
+                        return -EINVAL;
+
+                if (!accepting != !listening)
+                        return 0;
+        }
+
+        return 1;
+}
+
+int sd_is_socket(int fd, int family, int type, int listening) {
+        int r;
+
+        r = is_socket_internal(fd, type, listening);
+        if (r <= 0)
+                return r;
+
+        if (family > 0) {
+                union sockaddr_union sockaddr = {};
+                socklen_t l = sizeof(sockaddr);
+
+                if (getsockname(fd, &sockaddr.sa, &l) < 0)
+                        return -errno;
+
+                if (l < sizeof(sa_family_t))
+                        return -EINVAL;
+
+                return sockaddr.sa.sa_family == family;
+        }
+
+        return 1;
+}
