diff --git a/src/contrib/net.c b/src/contrib/net.c
index 0650937b1..68b565b79 100644
--- a/src/contrib/net.c
+++ b/src/contrib/net.c
@@ -32,6 +32,8 @@
 #include "contrib/sockaddr.h"
 #include "contrib/time.h"
 
+#include "contrib/sd-daemon.c"
+
 /*!
  * \brief Enable socket option.
  */
@@ -162,10 +164,34 @@ static void unlink_unix_socket(const struct sockaddr_storage *addr)
 	unlink(path);
 }
 
+static int get_systemd_socket(int family, int type, const struct sockaddr_storage *addr)
+{
+	int nsocks = sd_listen_fds(0);
+	for (int i=0; i < nsocks; i++) {
+		int fd = i + SD_LISTEN_FDS_START;
+		if (sd_is_socket(fd, family, type, -1) > 0) {
+			struct sockaddr_storage sdaddr = {};
+			socklen_t sdlen = sizeof(sdaddr);
+			if (getsockname(fd, (struct sockaddr*)&sdaddr, &sdlen) < 0) {
+				continue;
+			}
+			if (sockaddr_cmp(addr, &sdaddr, 0) == 0) {
+				return fd;
+			}
+		}
+	}
+	return -1;
+}
+
 int net_bound_socket(int type, const struct sockaddr_storage *addr, net_bind_flag_t flags)
 {
+	int sock;
+	if ((sock = get_systemd_socket(addr->ss_family, type, addr)) > 0) {
+		return sock;
+	}
+
 	/* Create socket. */
-	int sock = net_unbound_socket(type, addr);
+	sock = net_unbound_socket(type, addr);
 	if (sock < 0) {
 		return sock;
 	}
diff --git a/src/contrib/sd-daemon.c b/src/contrib/sd-daemon.c
new file mode 100644
index 000000000..62ce3adb6
--- /dev/null
+++ b/src/contrib/sd-daemon.c
@@ -0,0 +1,269 @@
+/* SPDX-License-Identifier: LGPL-2.1-or-later */
+
+
+#include <errno.h>
+#include <limits.h>
+#include <mqueue.h>
+#include <netinet/in.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/stat.h>
+#include <sys/un.h>
+#include <unistd.h>
+
+#define SD_LISTEN_FDS_START 3
+
+#include <stdbool.h>
+static union sockaddr_union {
+        /* The minimal, abstract version */
+        struct sockaddr sa;
+
+        /* The libc provided version that allocates "enough room" for every protocol */
+        struct sockaddr_storage storage;
+
+        /* Protoctol-specific implementations */
+        struct sockaddr_in in;
+        struct sockaddr_in6 in6;
+        struct sockaddr_un un;
+
+        /* Ensure there is enough space after the AF_UNIX sun_path for one more NUL byte, just to be sure that the path
+         * component is always followed by at least one NUL byte. */
+        uint8_t un_buffer[sizeof(struct sockaddr_un) + 1];
+};
+
+static int safe_atoi(const char *s, int *ret_i) {
+        unsigned base = 10;
+        char *x = NULL;
+        long l;
+
+        errno = 0;
+        l = strtol(s, &x, base);
+        if (errno > 0)
+                return -errno;
+        if (!x || x == s || *x != 0)
+                return -EINVAL;
+        if ((long) (int) l != l)
+                return -ERANGE;
+
+        if (ret_i)
+                *ret_i = (int) l;
+
+        return 0;
+}
+
+static int safe_atollu_full(const char *s, unsigned base, unsigned long long *ret_llu) {
+        char *x = NULL;
+        unsigned long long l;
+
+        errno = 0;
+        l = strtoull(s, &x, base);
+        if (errno > 0)
+                return -errno;
+        if (!x || x == s || *x != 0)
+                return -EINVAL;
+        if (l != 0 && s[0] == '-')
+                return -ERANGE;
+
+        if (ret_llu)
+                *ret_llu = l;
+
+        return 0;
+}
+
+static int safe_atou_full(const char *s, unsigned base, unsigned *ret_u) {
+        char *x = NULL;
+        unsigned long l;
+
+        errno = 0;
+        l = strtoul(s, &x, base);
+        if (errno > 0)
+                return -errno;
+        if (!x || x == s || *x != 0)
+                return -EINVAL;
+        if (l != 0 && s[0] == '-')
+                return -ERANGE;
+        if ((unsigned long) (unsigned) l != l)
+                return -ERANGE;
+
+        if (ret_u)
+                *ret_u = (unsigned) l;
+
+        return 0;
+}
+
+#if LONG_MAX == INT_MAX
+static inline int safe_atolu_full(const char *s, unsigned base, unsigned long *ret_u) {
+        return safe_atou_full(s, base, (unsigned*) ret_u);
+}
+#else
+static inline int safe_atolu_full(const char *s, unsigned base, unsigned long *ret_u) {
+        return safe_atollu_full(s, base, (unsigned long long*) ret_u);
+}
+#endif
+
+static inline int safe_atolu(const char *s, unsigned long *ret_u) {
+        return safe_atolu_full(s, 10, ret_u);
+}
+
+
+static inline int RET_NERRNO(int ret) {
+        if (ret < 0)
+                return -errno;
+        return ret;
+}
+
+static int fd_cloexec(int fd) {
+        int flags, nflags;
+
+        flags = fcntl(fd, F_GETFD, 0);
+        if (flags < 0)
+                return -errno;
+
+        nflags = flags | FD_CLOEXEC;
+        if (nflags == flags)
+                return 0;
+
+        return RET_NERRNO(fcntl(fd, F_SETFD, nflags));
+}
+
+static int parse_pid(const char *s, pid_t* ret_pid) {
+        unsigned long ul = 0;
+        pid_t pid;
+        int r;
+
+        r = safe_atolu(s, &ul);
+        if (r < 0)
+                return r;
+
+        pid = (pid_t) ul;
+
+        if ((unsigned long) pid != ul)
+                return -ERANGE;
+
+        if (pid <= 0)
+                return -ERANGE;
+
+        *ret_pid = pid;
+        return 0;
+}
+
+static void unsetenv_all(bool unset_environment) {
+        if (!unset_environment)
+                return;
+
+        unsetenv("LISTEN_PID");
+        unsetenv("LISTEN_FDS");
+        unsetenv("LISTEN_FDNAMES");
+}
+
+int sd_listen_fds(int unset_environment) {
+        const char *e;
+        int n, r;
+        pid_t pid;
+
+        e = getenv("LISTEN_PID");
+        if (!e) {
+                r = 0;
+                goto finish;
+        }
+
+        r = parse_pid(e, &pid);
+        if (r < 0)
+                goto finish;
+
+        /* Is this for us? */
+        if (getpid() != pid) {
+                r = 0;
+                goto finish;
+        }
+
+        e = getenv("LISTEN_FDS");
+        if (!e) {
+                r = 0;
+                goto finish;
+        }
+
+        r = safe_atoi(e, &n);
+        if (r < 0)
+                goto finish;
+
+        if (n <= 0 || n > INT_MAX - SD_LISTEN_FDS_START) {
+                r = -EINVAL;
+                goto finish;
+        }
+
+        for (int fd = SD_LISTEN_FDS_START; fd < SD_LISTEN_FDS_START + n; fd ++) {
+                r = fd_cloexec(fd);
+                if (r < 0)
+                        goto finish;
+        }
+
+        r = n;
+
+finish:
+        unsetenv_all(unset_environment);
+        return r;
+}
+
+static int is_socket_internal(int fd, int type, int listening) {
+        struct stat st_fd;
+
+        if (fstat(fd, &st_fd) < 0)
+                return -errno;
+
+        if (!S_ISSOCK(st_fd.st_mode))
+                return 0;
+
+        if (type != 0) {
+                int other_type = 0;
+                socklen_t l = sizeof(other_type);
+
+                if (getsockopt(fd, SOL_SOCKET, SO_TYPE, &other_type, &l) < 0)
+                        return -errno;
+
+                if (l != sizeof(other_type))
+                        return -EINVAL;
+
+                if (other_type != type)
+                        return 0;
+        }
+
+        if (listening >= 0) {
+                int accepting = 0;
+                socklen_t l = sizeof(accepting);
+
+                if (getsockopt(fd, SOL_SOCKET, SO_ACCEPTCONN, &accepting, &l) < 0)
+                        return -errno;
+
+                if (l != sizeof(accepting))
+                        return -EINVAL;
+
+                if (!accepting != !listening)
+                        return 0;
+        }
+
+        return 1;
+}
+
+int sd_is_socket(int fd, int family, int type, int listening) {
+        int r;
+
+        r = is_socket_internal(fd, type, listening);
+        if (r <= 0)
+                return r;
+
+        if (family > 0) {
+                union sockaddr_union sockaddr = {};
+                socklen_t l = sizeof(sockaddr);
+
+                if (getsockname(fd, &sockaddr.sa, &l) < 0)
+                        return -errno;
+
+                if (l < sizeof(sa_family_t))
+                        return -EINVAL;
+
+                return sockaddr.sa.sa_family == family;
+        }
+
+        return 1;
+}
